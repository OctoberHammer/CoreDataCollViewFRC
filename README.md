# CoreDataCollViewFRC
Для теста external/internal binary data  в  Core Data,


## Further Update by 2017.10.21

Добавил Realm, поды для кастомных кнопок.

Теперь при нажатии на кнопку "**Populate**" заполняются три ДатаСорса - две сущности в КорДате, и одна сущность в Релме.

Для Ячейки коллекшен вью использую протокол, которому конформны все три объекта модели.

Для Коллекшен Вью по-прежнему использую три разных класса контроллеров, хотя конечно их возможно генерализировать.
Но это возможно завтра.

В контроллере RealmVC тоже использую следилку апдейта релмовского объекта Results. Ничего экстраординарного, просто из доки Релма
https://realm.io/docs/swift/latest/#notifications , но применительно к КоллекшенВью, то есть performBatchUpdates



## Initial disclaimer
https://youtu.be/RkRuv_fSeN4

Проверяем как влиеят галка "**allow external storage**" в атрибутах сущностей КорДаты на потребление памяти.

В Модели у нас две почти одинаковые сущности, с атрибутами  **title** типа Строка и **picture** типа *Binary Data*. 
Но в одной из сущностей последний атррибут у нас с галкой "allow external storage".

Два практически одинаковых ВьюКонтроллера наследников КоллекшенВьюКонтроллера, используют в качество ДатаСорса **НСФетчедРезалтсКотроллер**, но каждый для своей сущности.

В навигейшенБаре - кнопка "**Populate**". По нажатию на нее мы с задержкой в 2 секунды создаем по 50 объектов одной и второй сущности, В атрибут **picture** помещаем один из файлов из Ассетсов. Сохраняем контекст.

Во ВьюКонтроллере срабатывает подписка на апдейт НСФетчедРезалтсКонтроллера, происходит вставка новых ячеек, и анимированный скроллинг вниз КоллекшенВью.


Мы Следим за потреблением памяти.


Если есть идеи как еще сравнить - форкайте проект, пишите сообщения.
